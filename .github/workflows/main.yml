name: CI/CD Pipeline

on:
  push:
    branches:
      - development

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Build Docker image
      run: |
        docker build -t quiz .
        docker images

    - name: Log in to Docker Hub
      run: echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin

    - name: Tag Docker image with commit SHA
      run: docker tag quiz ${{ secrets.DOCKER_USERNAME }}/quiz:${{ github.sha }}

    - name: Push Docker image to Docker Hub
      run: docker push ${{ secrets.DOCKER_USERNAME }}/quiz:${{ github.sha }}

  deploy:
    runs-on: ubuntu-latest

    needs: build-and-push  # Wait for the build-and-push job to finish successfully before starting deployment

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Update AWS CLI and configure
      run: |
        aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws configure set default.region ${{ secrets.AWS_REGION }}

    - name: Get existing ECS task definition and Update ECS task definition with new image
      run: |
        ecs_task_definition="${{ secrets.ECS_TASK_DEFINITION }}"
        # Extract the existing ECS task definition form AWS
        existing_task_definition=$(aws ecs describe-task-definition --task-definition "$ecs_task_definition" --output json)

        # New image URI
        new_image_uri="${{ secrets.DOCKER_USERNAME }}/quiz:${{ github.sha }}"
        
        # Extract family name from the current task definition
        family_name=$(echo "$existing_task_definition" | jq -r '.taskDefinition.family')
        echo $family_name
        
        # Update the image field in the container definition
        updated_task_definition=$(echo "$existing_task_definition" | jq --arg new_image_uri "$new_image_uri" '.taskDefinition.containerDefinitions[0].image = $new_image_uri' | jq 'del(.taskDefinition.revision)')

        updated_task_definition=$(echo "$updated_task_definition" | jq -c '{
          family: .taskDefinition.family,
          executionRoleArn: .taskDefinition.executionRoleArn,
          networkMode: .taskDefinition.networkMode,
          containerDefinitions: .taskDefinition.containerDefinitions,
          volumes: .taskDefinition.volumes,
          placementConstraints: .taskDefinition.placementConstraints,
          requiresCompatibilities: .taskDefinition.requiresCompatibilities,
          cpu: .taskDefinition.cpu,
          memory: .taskDefinition.memory 
        }')
       
        # Register the updated task definition as a new revision
        updated_task_definition=$(aws ecs register-task-definition --family "$family_name" --cli-input-json "$updated_task_definition")
    
    - name: Update ECS service to use the latest task definition
      run: |
        ecs_cluster_name="${{ secrets.ECS_CLUSTER_NAME }}"
        ecs_service_name="${{ secrets.ECS_SERVICE_NAME }}"
        ecs_task_definition="${{ secrets.ECS_TASK_DEFINITION }}"
        aws ecs update-service --cluster "$ecs_cluster_name" --service "$ecs_service_name" --task-definition "$ecs_task_definition"
  health-check:
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Use AWS CLI configured in deploy
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Wait for service to stabilize
        run: |
          ecs_cluster_name="${{ secrets.ECS_CLUSTER_NAME }}"
          ecs_service_name="${{ secrets.ECS_SERVICE_NAME }}"
          max_retries=30
          wait_interval=10

          for ((i=1; i<=$max_retries; i++)); do
            service_status=$(aws ecs describe-services --cluster "$ecs_cluster_name" --services "$ecs_service_name" --query 'services[0].status' --output text)
        
          if [ "$service_status" == "ACTIVE" ]; then
            echo "Service is up and running."
            exit 0
          fi

          echo "Service is not yet stable. Retrying in $wait_interval seconds (Attempt $i/$max_retries)..."
          sleep $wait_interval
          done

          echo "Service did not stabilize within the expected time."
          exit 1
