name: CI/CD Pipeline

on:
  push:
    branches:
      - development

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Build Docker image
      run: |
        docker build -t quiz .
        docker images
    - name: Log in to Docker Hub
      run: echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin

    - name: Tag Docker image with commit SHA
      run: docker tag quiz ${{ secrets.DOCKER_USERNAME }}/quiz:${{ github.sha }}

    - name: Push Docker image to Docker Hub
      run: docker push ${{ secrets.DOCKER_USERNAME }}/quiz:${{ github.sha }}

  deploy:
    runs-on: ubuntu-latest

    needs: build-and-push  # Wait for the build-and-push job to finish successfully before starting deployment

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Update AWS CLI and configure
      run: |
        aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws configure set default.region ${{ secrets.AWS_REGION }}
    - name: Get existing ECS task definition and Update ECS task definition with new image
      run: |
        ecs_task_definition="${{ secrets.ECS_TASK_DEFINITION }}"
        # Extract the existing ECS task definition form AWS
        existing_task_definition=$(aws ecs describe-task-definition --task-definition "$ecs_task_definition" --output json)
        # New image URI
        new_image_uri="${{ secrets.DOCKER_USERNAME }}/quiz:${{ github.sha }}"
        
        # Extract family name from the current task definition
        family_name=$(echo "$existing_task_definition" | jq -r '.taskDefinition.family')
        echo $family_name
        
        # Update the image field in the container definition
        updated_task_definition=$(echo "$existing_task_definition" | jq --arg new_image_uri "$new_image_uri" '.taskDefinition.containerDefinitions[0].image = $new_image_uri' | jq 'del(.taskDefinition.revision)')
        updated_task_definition=$(echo "$updated_task_definition" | jq -c '{
          family: .taskDefinition.family,
          executionRoleArn: .taskDefinition.executionRoleArn,
          networkMode: .taskDefinition.networkMode,
          containerDefinitions: .taskDefinition.containerDefinitions,
          volumes: .taskDefinition.volumes,
          placementConstraints: .taskDefinition.placementConstraints,
          requiresCompatibilities: .taskDefinition.requiresCompatibilities,
          cpu: .taskDefinition.cpu,
          memory: .taskDefinition.memory 
        }')
       
        # Register the updated task definition as a new revision
        updated_task_definition=$(aws ecs register-task-definition --family "$family_name" --cli-input-json "$updated_task_definition")
    
    - name: Update ECS service to use the latest task definition
      run: |
        ecs_cluster_name="${{ secrets.ECS_CLUSTER_NAME }}"
        ecs_service_name="${{ secrets.ECS_SERVICE_NAME }}"
        ecs_task_definition="${{ secrets.ECS_TASK_DEFINITION }}"
        aws ecs update-service --cluster "$ecs_cluster_name" --service "$ecs_service_name" --task-definition "$ecs_task_definition"
  health-check:
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Use AWS CLI configured in deploy
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Wait for service to stabilize
        run: |
          ecs_cluster_name="${{ secrets.ECS_CLUSTER_NAME }}"
          ecs_service_name="${{ secrets.ECS_SERVICE_NAME }}"
          max_retries=30
          wait_interval=10
          for ((i=1; i<=$max_retries; i++)); do
            service_status=$(aws ecs describe-services --cluster "$ecs_cluster_name" --services "$ecs_service_name" --query 'services[0].status' --output text)
        
          if [ "$service_status" == "ACTIVE" ]; then
            echo "Service is up and running."
            exit 0
          fi
          echo "Service is not yet stable. Retrying in $wait_interval seconds (Attempt $i/$max_retries)..."
          sleep $wait_interval
          done
          echo "Service did not stabilize within the expected time."
          exit 1
  Notification :
    runs-on: ubuntu-latest
    needs: health-check
    steps:
      - name: Use AWS CLI configured in deploy
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
  
      - name: Notify via SNS on job completion
        run: |
          topic_arn="${{ secrets.SNS_TOPIC_ARN }}"
          repository="${{ github.repository }}"
          sender_email="${{ secrets.SENDER_EMAIL }}"
          GITHUB_TOKEN="${{ secrets.TOKEN }}"
          jobs_status=$(echo "Job status for workflow run: ${{ github.run_id }}\n")
          echo "GitHub Token: $GITHUB_TOKEN"
          api_response=$(curl -s -X GET -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${repository}/actions/runs/${{ github.run_id }}/jobs")

          echo "API Response: $api_response"

          for job_name in "build-and-push" "deploy" "health-check"; do
              job_status=$(echo "$api_response" | jq -r ".jobs[] | select(.name == \"${job_name}\") | .conclusion // empty")

          if [ -z "$job_status" ]; then
              jobs_status="${jobs_status}❓ Job '${job_name}' status unknown\n"
          elif [ "$job_status" == "success" ]; then
              jobs_status="${jobs_status}✅ Job '${job_name}' passed\n"
          else
              jobs_status="${jobs_status}❌ Job '${job_name}' failed\n"
           fi
          done


          subject="Quiz Application CI/CD Pipeline Notification"
          message="${jobs_status}\nRepository: ${repository}\nWorkflow Run ID: ${{ github.run_id }}"

          aws sns publish --topic-arn "$topic_arn" --message "$message" --subject "$subject" --message-attributes "{\"email\":{\"DataType\":\"String\",\"StringValue\":\"$sender_email\"}}"
